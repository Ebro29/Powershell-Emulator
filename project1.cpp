//Ebrahim Shahid
//Operating Systems - Fall 2018
//Project #1 - Writing your own Shell

//Includes and Defines
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <sys/wait.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <signal.h>
#include <limits.h>
#include <errno.h>
#include <setjmp.h>
#include <iostream>

using namespace std;

#define CMD_HISTORY_SIZE 10
#define BUFFERSIZE 500
#define MAXARGS 512
#define READ  0
#define WRITE 1
#define MAX_WORD 10
#define MAX_CHAR 100
#define DEL " "

//global variable definitions
static int run(char* cmd, int input, int initial, int final);
static char line[1024];
static int n = 0; /* number of calls to 'command' */
static char* args[512];
static char * cmd_history[CMD_HISTORY_SIZE];
static int cmd_history_count = 0;
pid_t pid;
sigjmp_buf jmpenv;

static int command(int input, int initial, int final)
{
	int pipes[2];
	pipe( pipes );
	pid = fork();


//These if statements will handle I/O redirection with the dup2 commands
	if (pid == 0) {
		if (initial == 1 && final == 0 && input == 0) {
			// initial command
			dup2( pipes[WRITE], STDOUT_FILENO );
		} else if (initial == 0 && final == 0 && input != 0) {
			// Middle command
			dup2(input, STDIN_FILENO);
			dup2(pipes[WRITE], STDOUT_FILENO);
		} else {
			// Final command
			dup2( input, STDIN_FILENO );
		}
		if (execvp( args[0], args) == -1)
			_exit(EXIT_FAILURE); // If child fails
	}

	if (input != 0)
		close(input);
	close(pipes[WRITE]);
	if (final == 1)
		close(pipes[READ]);
	return pipes[READ];
}

static void exec_cmd(const char * line)
{
	char * CMD = strdup(line);
	char * params[10];
	int argc = 0;

	params[argc++]=strtok(CMD," ");
	while(params[argc-1]!=NULL){
		params[argc++]=strtok(NULL," ");
	}
	argc--;

	int background = 0;
	if(strcmp(params[argc-1],"&")==0){
		background = 1;
		params[--argc] = NULL;
	}

	int fd[2] = {-1,-1};
	while(argc>=3){
		if(strcmp(params[argc-2],">") == 0)
		{

			fd[1]=open(params[argc-1],O_CREAT|O_WRONLY|O_TRUNC,S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP);
			if(fd[1]== -1){
				perror("open");
				free(CMD);
				return;
			}

			params[argc-2]= NULL;
			argc-=2;

			}
			else if(strcmp(params[argc-2],"<")==0){ //Input
				fd[0]= open(params[argc-1],O_RDONLY);
				if(fd[0]==-1){
					perror("open");
					free(CMD);
					return;
			}

			params[argc-2] = NULL;
			argc-=2;

			}
			else
			{
				break;
			}
		}
	int status;
	pid_t pid = fork();
	switch(pid)
	{
		case -1:
			perror("fork");
			break;
		case 0: //child
			if(fd[0] != -1)
			{
				if(dup2(fd[0],STDIN_FILENO) != STDIN_FILENO)
				{
					perror("dup2");
					exit(1);
				}
			}
		if(fd[0] != -1){
			if(dup2(fd[1],STDOUT_FILENO) != STDIN_FILENO)
				{
					perror("dup2");
					exit(1);
				}
		}

		execvp(params[0],params);
		perror("execvp");
		exit(0);

		default://parent
			close(fd[0]);
			close(fd[1]);
			if(!background)
				waitpid(pid,&status,0);
			break;
	}
	free(CMD);
}

static void add_to_history(const char * cmd)
{
	if(cmd_history_count == (CMD_HISTORY_SIZE-1))
	{
		int i;
		free(cmd_history[0]);

		for(i=1;i<cmd_history_count;i++)
			cmd_history[i-1] = cmd_history[i];
		cmd_history_count--;
	}

	cmd_history[cmd_history_count++] = strdup(cmd);
}

static void run_from_history(const char * cmd)
{
	int index = 0;
	if(cmd_history_count  == 0)
	{
		printf("No commands in history \n");
		return;
	}
	if(cmd[1] == '!')
		index = cmd_history_count-1;
	else
	{
		index = atoi(&cmd[1])-1;
		if((index<0) || (index > cmd_history_count)) //Error Handling
		{
			fprintf(stderr, "No such command in history.\n");
			return;
		}
	}

	printf("%s\n", cmd);
	exec_cmd(cmd_history[index]);
}

static void list_history()
{
	int i;
	for (i=cmd_history_count-1; i >= 0; i--)
	{
		printf("%i%s\n",i+1,cmd_history[i]);
	}
}

static void signal_handler(const int rc)
{
    if (args[0] != NULL) {
		if (strcmp(args[0], "exit") == 0 || strcmp(args[0], "quit") == 0)
		{   list_history();
			exit(0);
        }
    }

	switch(rc)
	{
		case SIGTERM:

		case SIGINT:

			break;

		case SIGCHLD:

			while(waitpid(-1,NULL,WNOHANG)>0);
			break;
	}
}

/* Monte Carlo Simulator */
unsigned long int seg_fault = 0; // count for generated segfaults due to attempts
unsigned long int attempts = 0; // count for evaluations attempted

// functions
void handler_seg (int sig);
void handler_int (int sig);
void handler_tstp (int sig);
void handler_alrm (int arg);
void handler_usr1 (int sig);
void handler_usr2 (int sig);
int capture_Signals();

/*Generated by CTRL-C*/
void handler_int (int sig)
{
    cout << "SIG_INT called" << endl;
    cout << "Total number of SEG_FAULTS: " << seg_fault << endl;
    cout << "Total number of evaluations: " << attempts << endl;
    double percent = seg_fault/attempts;
    cout << "The percentage of seg_fault attempts: " << percent << endl;
    //exit ((int)percent); commented out so that CTRL-C does NOT close the program as instructed
}

/*Generated by CTRL-Z, reports the current results without stopping program*/
void handler_tstp (int sig)
{
    cout << "SIG_TSTP called" << endl;
    cout << "Total number of SEG_FAULTS: " << seg_fault << endl;
    cout << "Total number of evaluations: " << attempts << endl;
    double percent = seg_fault/attempts;
    cout << "The percentage of seg_fault attempts: " << percent << endl;
    return; // can go right back to what you were doing because no errors to report
}

void handler_seg (int sig)
{
    seg_fault++;
    attempts++;
    // return of the handler if eval counter hasnt reached the limit ulong_max
    if (attempts == ULONG_MAX)
    {
        cout << "SIG_INT called" << endl;
        cout << "Total number of SEG_FAULTS: " << seg_fault << endl;
        cout << "Total number of evaluations: " << attempts << endl;
        double percent = seg_fault/attempts;
        cout << "The percentage of seg_fault attempts: " << percent << endl;
        //exit ((int)percent); commented out so only the exit or quit command closes the program
    }
}

int main(int argc, char *argv[])
{
	struct sigaction act, act_old;
	act.sa_handler = signal_handler;
	act.sa_flags = 0;
	sigemptyset(&act.sa_mask);
	char buffer[BUFFERSIZE]; // define BUFFERSIZE 500
    fgets(buffer, BUFFERSIZE , stdin);
    printf("Welcome to the Islander Shell, press enter to begin: ");
    printf("Read: %s", buffer);
	if( (sigaction(SIGINT,&act,&act_old)==-1) ||(sigaction(SIGCHLD,&act, &act_old) == -1) )
	{
		perror ("signal");
		return 1;
	}

	size_t line_size = 100;
	char * line = (char*) malloc(sizeof(char)*line_size);
	if(line == NULL)
	{
		perror("malloc");
		return 1;
	}
	int interr = 0;

	while (1)
	{
    srand (time(NULL));
    int count = 0;
    char *cargs[MAXARGS];
    int alrmReq = 0;

// need to parse any command line arguments that are present
    for (int i=0 ; i<argc ; i++)
    {
        cout << argv[i] << endl;
        cargs[i] = argv[i];
        if (i == argc-1)
            alrmReq = atoi(argv[i]); // set the alarm value
    }

// Set up signal handlers to catch and respond to certain signals
    signal (SIGSEGV, handler_seg);

// for loop to generate and test random addresses using global eval
// counter for the loop counter
    if (alrmReq > 0)
    {
        alarm (alrmReq);
        signal (SIGALRM, handler_alrm);
    }

    int* address_ptr = NULL; // initialization only occurs for the first run in a loop
    int temp = 0;
    int report = 10;
    for (attempts=0; attempts<100 ; attempts++) // ULONG_MAX
    {
        sigsetjmp(jmpenv,0); // remembers the context at the beginnging of the loop
        attempts++;
        address_ptr = (int*)rand(); // possibly not all the mem locations
    // attempt to read from possible seg_fault location
        temp = *address_ptr; // for seg fault returns back to redo instruction that caused the fault

    // check if attempts is a power of 10
        if (attempts == report)
        {
        //child use the kill command to send SIGUSR1 signal to parent
            signal (SIGUSR1, handler_usr1);
            report = report*10;
        }
        cout << "Successfully completed the for loop" << endl;
        cout << "Total number of SEG_FAULTS: " << seg_fault << endl;
        cout << "Total number of evaluations: " << attempts << endl;
        double percent = seg_fault/attempts;
        cout << "The percentage of seg_fault attempts: " << percent << endl;
        exit ((int)percent);

		if(!interr)
			printf("mysh > ");
		if(getline(&line,&line_size,stdin) == -1)
		{
			if(errno == EINTR)
			{
				clearerr(stdin);
				interr = 1;
				continue;
			}
			perror("getline");
			break;
		}
		interr = 0;
		int line_len = strlen(line);
		if(line_len == 1)
		{
			continue;
		}

		line[line_len-1] = '\0';

		if(strcmp(line,"exit") == 0)
		{
			break;
		}
		else if (strcmp(line, "hist") == 0) //hist command implementation
		{
			list_history();
		}
		else if (line[0] == '!')
		{
			run_from_history(line);
		}
		else
		{
			add_to_history(line);
			exec_cmd(line);
		}
	}

	free(line);
	list_history(); //display history on termination
	return 0;
}
}

